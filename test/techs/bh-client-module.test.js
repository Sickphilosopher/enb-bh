var fs = require('fs'),
    path = require('path'),
    mock = require('mock-fs'),
    promisify = require('vow-node').promisify,
    http = require('http'),
    serveStatic = require('serve-static'),
    finalhandler = require('finalhandler'),
    TestNode = require('enb/lib/test/mocks/test-node'),
    FileList = require('enb/lib/file-list'),
    bhClientModule = require('../../techs/bh-client-module'),
    bhCoreFilename = require.resolve('bh/lib/bh.js'),
    htmlFilename = path.join(__dirname, '..', 'fixtures', 'bh-client-module', 'index.html'),
    mochaFilename = require.resolve('mocha/mocha.js'),
    chaiFilename = require.resolve('chai/chai.js'),
    ymFilename = require.resolve('ym/modules.js'),
    writeFile = require('../lib/write-file'),
    runPhantom = require('../lib/run-phantom'),
    serve, server, listen;

describe('bh-client-module', function () {
    beforeEach(function () {
        serve = serveStatic(process.cwd(), { index: false });
        server = http.createServer(function (req, res) {
            var done = finalhandler(req, res);

            serve(req, res, done);
        });
        listen = promisify(server.listen.bind(server));
    });

    afterEach(function () {
        mock.restore();
    });

    it('compiled files should works on client-side', function () {
        var test = generateTest({ block: 'block' }, '<a class="block"></a>');

        return runTest(test);
    });

    it('custom core', function () {
        var test = generateTest({ block: 'block' }, '^_^'),
            options = {
                bhFile: [
                    'function BH () {}',
                    'BH.prototype.apply = function() { return "^_^"; };',
                    'BH.prototype.match = function() {};',
                    'BH.prototype.setOptions = function() {};'
                ].join('\n')
            };

        return runTest(test, options);
    });

    it('mimic', function () {
        var test = [
                'chai.should();',
                'describe("bh-client-module", function () {',
                    'it("autogenerated test", function (done) {',
                        'modules.require("BEMHTML", function (BEMHTML) {',
                            'BEMHTML.apply({ block: "block" }).should.equal(\'<a class="block"></a>\');',
                            'done();',
                        '});',
                    '});',
                '});'
            ].join('\n'),
            options = {
                mimic: 'BEMHTML'
            };

       return runTest(test, options);
    });

    describe('jsAttr', function () {
        it('should use dafault jsAttrName and jsAttrScheme params', function () {
            var test = generateTest(
                { block: 'block', js: true },
                '<a class="block i-bem" onclick="return {&quot;block&quot;:{}}"></a>'
            );

           return runTest(test);
        });

        it('should use redefined jsAttrName param', function () {
            var test = generateTest(
                    { block: 'block', js: true },
                    '<a class="block i-bem" data-bem="return {&quot;block&quot;:{}}"></a>'
                ),
                options = {
                    jsAttrName: 'data-bem'
                };

           return runTest(test, options);
        });

        it('should use redefined jsAttrScheme param', function () {
            var test = generateTest(
                    { block: 'block', js: true },
                    '<a class="block i-bem" onclick="{&quot;block&quot;:{}}"></a>'
                ),
                options = {
                    jsAttrScheme: 'json'
                };

           return runTest(test, options);
        });
    });

    it('dependencies', function () {
        var test = generateTest({ block: 'block' }, '<div class="block">^_^</div>'),
            options = {
                dependencies: { A: 'A' }
            },
            template = 'bh.match("block", function(ctx) { ctx.content(bh.lib.A); });',
            lib = 'modules.define("A", function (provide) { provide("^_^"); });';

       return runTest(test, options, template, lib);
    });

    it('sourcemap', function () {
        var options = {
                sourcemap: true,
                bhFile: 'bh.js'
            },
            scheme = {
                blocks: {},
                bundle: {},
                'bh.js': 'module.exports = BH;'
            },
            bundle, fileList;

        mock(scheme);

        bundle = new TestNode('bundle');
        fileList = new FileList();
        fileList.loadFromDirSync('blocks');
        bundle.provideTechData('?.files', fileList);

        return bundle.runTechAndGetContent(bhClientModule, options)
            .spread(function (bh) {
                bh.toString().must.include('sourceMappingURL');
            });
    });

    describe('caches', function () {
        var mockBhCore, scheme, bundle, fileList;

        beforeEach(function () {
            mockBhCore = [
                'function BH () {}',
                'BH.prototype.apply = function() { return "^_^"; };',
                'BH.prototype.match = function() {};',
                'BH.prototype.setOptions = function() {};'
            ].join('\n');
            scheme = {
                blocks: {},
                bundle: {},
                'index.html': fs.readFileSync(htmlFilename, 'utf-8'),
                'mocha.js': fs.readFileSync(mochaFilename, 'utf-8'),
                'chai.js': fs.readFileSync(chaiFilename, 'utf-8'),
                'ym.js': fs.readFileSync(ymFilename, 'utf-8')
            };
        });

        afterEach(function () {
            server.close();
        });

        it('must use cached bhFile', function () {
            scheme['test.js'] = generateTest({ block: 'block' }, '<div class="block"></div>');

            scheme[bhCoreFilename] = mock.file({
                content: fs.readFileSync(bhCoreFilename, 'utf-8'),
                mtime: new Date(1)
            });

            /*
             * Добавляем кастомное ядро с mtime для проверки кэша.
             * Если mtime кастомного ядра совпадет с mtime родного ядра,
             * то должно быть использовано родное(закешированное).
             */
            scheme['mock.bh.js'] = mock.file({
                content: mockBhCore,
                mtime: new Date(1)
            });

            mock(scheme);

            bundle = new TestNode('bundle');
            fileList = new FileList();
            fileList.loadFromDirSync('blocks');
            bundle.provideTechData('?.files', fileList);

            return bundle.runTech(bhClientModule)
                .then(function () {
                    return bundle.runTechAndGetContent(bhClientModule, { bhFile: 'mock.bh.js' });
                })
                .spread(function (bh) {
                    fs.writeFileSync('bundle/bundle.bh.js', bh);
                    // TODO: удалить, когда пофиксится https://github.com/enb-make/enb/issues/224

                    return listen(3000);
                })
                .then(function () {
                    return runPhantom('http://localhost:3000/index.html');
                })
                .fail(function (err) {
                    throw err;
                });
        });

        it('must rewrite cached bhFile if the new bhFile exist', function () {
            scheme['test.js'] = generateTest({ block: 'block' }, '^_^');

            scheme[bhCoreFilename] = mock.file({
                content: fs.readFileSync(bhCoreFilename, 'utf-8'),
                mtime: new Date(1)
            });

            /*
             * Добавляем кастомное ядро с mtime для проверки кэша.
             * Если mtime разные, то должно использоваться кастомное ядро
             * (кэш должен перезаписаться)
             */
            scheme['mock.bh.js'] = mock.file({
                content: mockBhCore,
                mtime: new Date(2)
            });

            mock(scheme);

            bundle = new TestNode('bundle');
            fileList = new FileList();
            fileList.loadFromDirSync('blocks');
            bundle.provideTechData('?.files', fileList);

            return bundle.runTech(bhClientModule)
                .then(function () {
                    return bundle.runTechAndGetContent(bhClientModule, { bhFile: 'mock.bh.js' });
                })
                .spread(function (bh) {
                    fs.writeFileSync('bundle/bundle.bh.js', bh);
                    // TODO: удалить, когда пофиксится https://github.com/enb-make/enb/issues/224

                    return listen(3000);
                })
                .then(function () {
                    return runPhantom('http://localhost:3000/index.html');
                })
                .fail(function (err) {
                    throw err;
                });
        });

        it('must ignore outdated cache of the templates', function () {
            scheme['test.js'] = generateTest({ block: 'block' }, '<b class="block"></b>');
            scheme.blocks['block.bh.js'] = bhWrap('bh.match("block", function(ctx) {ctx.tag("a");});');
            scheme[bhCoreFilename] = fs.readFileSync(bhCoreFilename, 'utf-8');

            mock(scheme);

            bundle = new TestNode('bundle');
            fileList = new FileList();
            fileList.loadFromDirSync('blocks');
            bundle.provideTechData('?.files', fileList);

            return bundle.runTech(bhClientModule)
                .then(function () {
                    return writeFile(
                        'blocks/block.bh.js',
                        bhWrap('bh.match("block", function(ctx) {ctx.tag("b");});')
                    );
                })
                .then(function () {
                    fileList = new FileList();
                    fileList.loadFromDirSync('blocks');
                    bundle.provideTechData('?.files', fileList);

                    return bundle.runTechAndGetContent(bhClientModule);
                })
                .spread(function (bh) {
                    fs.writeFileSync('bundle/bundle.bh.js', bh);
                    // TODO: удалить, когда пофиксится https://github.com/enb-make/enb/issues/224

                    return listen(3000);
                })
                .then(function () {
                    return runPhantom('http://localhost:3000/index.html');
                })
                .fail(function (err) {
                    throw err;
                });
        });
    });
});

function bhWrap(str) {
    return 'module.exports = function(bh) {' + str + '};';
}

function runTest(testContent, options, template, lib) {
    var bhTemplate = bhWrap(template || 'bh.match("block", function(ctx) { ctx.tag("a"); });'),
        bundle,
        fileList,

        scheme = {
            blocks: {
                'block.bh.js': bhTemplate
            },
            bundle: {},
            'index.html': fs.readFileSync(htmlFilename, 'utf-8'),
            'test.js': testContent,
            'mocha.js': fs.readFileSync(mochaFilename, 'utf-8'),
            'chai.js': fs.readFileSync(chaiFilename, 'utf-8'),
            'ym.js': fs.readFileSync(ymFilename, 'utf-8')
        };

    if (options && options.bhFile) {
        scheme['bh.js'] = options.bhFile;
        options.bhFile = 'bh.js';
    }

    if (lib) {
        scheme['some-ym-lib.js'] = lib;
    }

    scheme[bhCoreFilename] = fs.readFileSync(bhCoreFilename, 'utf-8');

    mock(scheme);

    bundle = new TestNode('bundle');
    fileList = new FileList();
    fileList.loadFromDirSync('blocks');
    bundle.provideTechData('?.files', fileList);

    return bundle.runTechAndGetContent(bhClientModule, options)
        .spread(function (bh) {
            fs.writeFileSync('bundle/bundle.bh.js', bh);
            // TODO: удалить, когда пофиксится https://github.com/enb-make/enb/issues/224

            return listen(3000);
        })
        .then(function () {
            return runPhantom('http://localhost:3000/index.html');
        })
        .then(function () {
            server.close();
        })
        .fail(function (err) {
            throw err;
        });
}

function generateTest(json, result) {
    return [
            'chai.should();',
            'describe("bh-client-module", function () {',
                'it("autogenerated test", function (done) {',
                    'modules.require("bh", function (bh) {',
                        'bh.apply(' + JSON.stringify(json) + ').should.equal(\'' + result.toString() + '\');',
                        'done();',
                    '});',
                '});',
            '});'
    ].join('\n');
}

